--[[
    Protected Calculator Module for Lurnai
    Â© 2025 Havoc - All Rights Reserved
    
    This script uses multiple layers of protection:
    1. Environment verification
    2. Call stack validation
    3. Anti-tampering checks
    4. Obfuscated critical data
    5. Self-verification mechanisms
]]

-- Create a secure environment with closure protection
local Calculator = (function()
    -- Internal module
    local module = {}
    
    -- Security constants (obfuscated)
    local SECURITY = {
        AUTH_KEY = string.char(76,117,114,110,97,105,95,72,97,118,111,99,95,65,117,116,104), -- "Lurnai_Havoc_Auth"
        SCRIPT_NAME = string.char(76,117,114,110,97,105,32,45,32,70,114,101,101,32,86,101,114,115,105,111,110), -- "Lurnai - Free Version"
        AUTHOR = string.char(72,97,118,111,99), -- "Havoc"
        UI_LIB = string.char(70,108,117,101,110,116), -- "Fluent"
        FLOOD_COUNT = 500
    }
    
    -- Utility functions
    local function floodConsole()
        for i = 1, SECURITY.FLOOD_COUNT do
            print("")
        end
    end
    
    local function generateHash(str)
        local hash = 0
        for i = 1, #str do
            hash = ((hash << 5) - hash) + string.byte(str, i)
            hash = hash & 0xFFFFFFFF
        end
        return hash
    end
    
    -- Create a unique identifier for this instance
    local instanceId = tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
    
    -- Store the original metatable functions to prevent tampering
    local originalMetamethods = {
        setmetatable = setmetatable,
        getmetatable = getmetatable,
        rawget = rawget,
        rawset = rawset,
        pairs = pairs,
        ipairs = ipairs
    }
    
    -- Store the original environment functions
    local originalEnvFunctions = {
        getfenv = getfenv,
        setfenv = setfenv,
        loadstring = loadstring,
        debug = {
            traceback = debug.traceback,
            getinfo = debug.getinfo
        }
    }
    
    -- Verify the execution environment
    local function verifyEnvironment()
        -- Check if critical functions have been tampered with
        if setmetatable ~= originalMetamethods.setmetatable or
           getmetatable ~= originalMetamethods.getmetatable or
           rawget ~= originalMetamethods.rawget or
           rawset ~= originalMetamethods.rawset or
           pairs ~= originalMetamethods.pairs or
           ipairs ~= originalMetamethods.ipairs or
           getfenv ~= originalEnvFunctions.getfenv or
           setfenv ~= originalEnvFunctions.setfenv or
           loadstring ~= originalEnvFunctions.loadstring or
           debug.traceback ~= originalEnvFunctions.debug.traceback or
           debug.getinfo ~= originalEnvFunctions.debug.getinfo then
            return false
        end
        
        return true
    end
    
    -- Check if this is being loaded by the authorized UI
    local function isAuthorizedLoader()
        local success, result = pcall(function()
            -- Get the call stack to check who's loading this script
            local callStack = originalEnvFunctions.debug.traceback()
            
            -- Check for specific identifiers that should only exist in your UI
            local isLurnai = callStack:find("Lurnai") ~= nil
            local isHavoc = callStack:find(SECURITY.AUTHOR) ~= nil
            local hasCorrectTitle = callStack:find(SECURITY.SCRIPT_NAME:gsub("%-", "%%-")) ~= nil
            local hasFluentUI = callStack:find(SECURITY.UI_LIB) ~= nil
            
            -- Get the script name that's loading this
            local info = originalEnvFunctions.debug.getinfo(3, "S")
            local scriptName = info and info.source or ""
            
            -- Check if the script name contains our expected name
            local hasCorrectScriptName = scriptName:find("Lurnai") ~= nil
            
            -- Check if the script is being loaded from the correct context
            local loadedFromCorrectContext = 
                isLurnai and isHavoc and (hasFluentUI or hasCorrectTitle or hasCorrectScriptName)
            
            if not loadedFromCorrectContext then
                floodConsole()
                return false
            end
            
            return true
        end)
        
        return success and result
    end
    
    -- Generate a unique key based on the environment
    local function generateAuthKey()
        local env = originalEnvFunctions.getfenv(2)
        local authComponents = {
            os.time(),
            tostring(env),
            SECURITY.AUTH_KEY,
            instanceId
        }
        
        local authString = table.concat(authComponents, "_")
        local authKey = ""
        
        for i = 1, #authString do
            authKey = authKey .. string.char(string.byte(authString:sub(i,i)) + 3)
        end
        
        return authKey
    end
    
    -- Check if environment is valid
    if not verifyEnvironment() or not isAuthorizedLoader() then
        floodConsole()
        -- Return a fake "broken" calculator that appears to be non-functional
        return {
            CalculateRock = function() 
                floodConsole()
                return "Calculator is currently experiencing issues. Please try again later."
            end,
            Rocks = {},
            PetTypes = {},
            _isBroken = true, -- Flag to indicate this is a fake broken version
            VerifyAuthenticity = function() return false end
        }
    end
    
    -- Create a secure environment for data
    local secureEnv = {}
    
    -- Actual calculator data (obfuscated for additional security)
    local realData = {
        PetTypes = {
            Unique = {0, 1250, 3750, 7500, 12500, 18750, 26250, 35000, 45000, 56250, 68750, 82500, 97500, 113750, 131250, 150000, 170000, 191250, 213750, 237500},
            Epic = {0, 1000, 3000, 6000, 10000, 15000, 21000, 28000, 36000, 45000, 55000, 66000, 78000, 91000, 105000, 120000, 136000, 153000, 171000, 190000, 210000},
            Rare = {0, 750, 2250, 4500, 7500, 11250, 15750, 21000, 27000, 33750, 41250, 49500, 58500, 68250, 78750, 90000, 102000, 114750, 128250, 142500, 157500},
            Advanced = {0, 500, 1500, 3000, 5000, 7500, 10500, 14000, 18000, 22500, 27500, 33000, 39000, 45500, 52500, 60000, 68000, 76500, 85500, 95000, 105000},
            Basic = {0, 250, 750, 1500, 2500, 3750, 5250, 7000, 9000, 11250, 13750, 16500, 19500, 22750, 26250, 30000, 34000, 38250, 42750, 47500, 52500},
            ["Unique Aura"] = {0, 3000, 7500, 13500, 21000, 30000, 40500, 52500, 66000, 81000, 97500, 115500, 135000, 156000, 178500, 202500, 228000, 255000, 283500, 313500, 345000}
        },
        Rocks = {
            { name = 'Jungle Rock', multiplier = 16.25 },
            { name = 'Muscle King Rock', multiplier = 12.5 },
            { name = 'Legends Rock', multiplier = 2.5 },
            { name = 'Inferno Rock', multiplier = 1.125 },
            { name = 'Mystic Rock', multiplier = 0.75 },
            { name = 'Frozen Rock', multiplier = 0.375 },
            { name = 'Golden Rock', multiplier = 0.2 },
            { name = 'Large Rock', multiplier = 0.075 },
            { name = 'Punching Rock', multiplier = 0.05 },
            { name = 'Tiny Rock', multiplier = 0.025 }
        }
    }
    
    -- Add security identifiers
    module._lurnaiAuthKey = generateAuthKey()
    module._loadTime = os.time()
    module._verificationHash = string.format("%x", generateHash(instanceId .. SECURITY.AUTH_KEY))
    module._isBroken = false -- Flag to indicate this is the real version
    module._instanceId = instanceId
    
    -- Create proxy tables to prevent direct access to data
    local proxyMetatable = {
        __index = function(t, k)
            local callStack = originalEnvFunctions.debug.traceback()
            if not callStack:find("Lurnai") then
                floodConsole()
                return nil
            end
            return originalMetamethods.rawget(secureEnv, k)
        end,
        __newindex = function(t, k, v)
            floodConsole()
            return nil
        end,
        __metatable = "Locked metatable"
    }
    
    -- Set up the proxies
    secureEnv.PetTypes = {}
    secureEnv.Rocks = {}
    
    -- Copy data to secure environment
    for k, v in pairs(realData.PetTypes) do
        secureEnv.PetTypes[k] = v
    end
    
    for i, v in ipairs(realData.Rocks) do
        secureEnv.Rocks[i] = v
    end
    
    -- Create a hash of the original data for integrity checking
    local dataHash = generateHash(tostring(realData))
    module._dataIntegrityHash = dataHash
    
    -- Expose the data through proxies with additional security
    module.PetTypes = originalMetamethods.setmetatable({}, {
        __index = function(t, k)
            -- Verify environment hasn't been tampered with
            if not verifyEnvironment() then
                floodConsole()
                return nil
            end
            
            local callStack = originalEnvFunctions.debug.traceback()
            if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
                floodConsole()
                return nil
            end
            
            -- Verify data integrity
            if generateHash(tostring(realData)) ~= dataHash then
                floodConsole()
                return nil
            end
            
            return secureEnv.PetTypes[k]
        end,
        __newindex = function() floodConsole() end,
        __metatable = "Locked metatable"
    })
    
    module.Rocks = originalMetamethods.setmetatable({}, {
        __index = function(t, k)
            -- Verify environment hasn't been tampered with
            if not verifyEnvironment() then
                floodConsole()
                return nil
            end
            
            local callStack = originalEnvFunctions.debug.traceback()
            if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
                floodConsole()
                return nil
            end
            
            -- Verify data integrity
            if generateHash(tostring(realData)) ~= dataHash then
                floodConsole()
                return nil
            end
            
            return secureEnv.Rocks[k]
        end,
        __newindex = function() floodConsole() end,
        __metatable = "Locked metatable",
        __len = function() 
            if not verifyEnvironment() then
                floodConsole()
                return 0
            end
            return #secureEnv.Rocks 
        end,
        __pairs = function(t)
            if not verifyEnvironment() then
                floodConsole()
                return function() return nil end
            end
            
            local callStack = originalEnvFunctions.debug.traceback()
            if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
                floodConsole()
                return function() return nil end
            end
            
            local i = 0
            return function()
                i = i + 1
                if i <= #secureEnv.Rocks then
                    return i, secureEnv.Rocks[i]
                end
            end
        end,
        __ipairs = function(t)
            if not verifyEnvironment() then
                floodConsole()
                return function() return nil end
            end
            
            local callStack = originalEnvFunctions.debug.traceback()
            if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
                floodConsole()
                return function() return nil end
            end
            
            local i = 0
            return function()
                i = i + 1
                if i <= #secureEnv.Rocks then
                    return i, secureEnv.Rocks[i]
                end
            end
        end
    })
    
    -- The calculation function with enhanced security
    function module:CalculateRock(rebirths, rockName, petType)
        -- Verify environment hasn't been tampered with
        if not verifyEnvironment() then
            floodConsole()
            return "Access denied: Environment compromised"
        end
        
        -- Check if being called from the right context
        local callStack = originalEnvFunctions.debug.traceback()
        if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
            floodConsole()
            return "Access denied: Unauthorized caller"
        end
        
        -- Verify the auth key hasn't been tampered with
        if not self._lurnaiAuthKey or self._lurnaiAuthKey:len() < 10 then
            floodConsole()
            return "Authentication failed: Invalid key"
        end
        
        -- Verify data integrity
        if generateHash(tostring(realData)) ~= dataHash then
            floodConsole()
            return "Data integrity check failed"
        end
        
        -- Verify this module hasn't been renamed
        local info = originalEnvFunctions.debug.getinfo(1, "f")
        if info and info.func ~= module.CalculateRock then
            floodConsole()
            return "Function integrity check failed"
        end
        
        local multiplier = nil
        for _, rock in ipairs(secureEnv.Rocks) do
            if rock.name == rockName then
                multiplier = rock.multiplier
                break
            end
        end
        
        if not multiplier then
            return "Rock not found"
        end
        
        local xpLevels = secureEnv.PetTypes[petType]
        if not xpLevels then
            return "Pet type not found"
        end
        
        -- Calculate total XP based on rebirths and rock multiplier
        local total = (rebirths + 20) * multiplier
        
        -- Check if total has a decimal part
        if total ~= math.floor(total) then
            return "Not Glitchable"
        end
        
        -- Check if total exceeds max level
        if total > xpLevels[#xpLevels] then
            return "Not Glitchable"
        end
        
        -- Check if total is exactly one of the XP levels (perfect level up)
        for i, xp in ipairs(xpLevels) do
            if total == xp then
                return "Level 1, 0xp"
            end
        end
        
        -- Find the next XP level
        local nextXP = nil
        for i, xp in ipairs(xpLevels) do
            if xp > total then
                nextXP = xp
                break
            end
        end
        
        if not nextXP then
            return "Not Glitchable"
        end
        
        -- Calculate the first difference
        local firstDiff = nextXP - total
        
        -- Find the level based on where firstDiff falls in the XP levels
        local level = 1
        for i, xp in ipairs(xpLevels) do
            if firstDiff <= xp then
                level = i - 1
                break
            end
        end
        
        -- Calculate the remaining XP
        local baseXP = 0
        if level > 0 and level < #xpLevels then
            baseXP = xpLevels[level]
        end
        
        local remainingXP = math.floor(firstDiff - baseXP)
        
        return "Level " .. level .. ", " .. remainingXP .. "xp"
    end
    
    -- Add a verification method that the UI can call
    function module:VerifyAuthenticity()
        -- Verify environment hasn't been tampered with
        if not verifyEnvironment() then
            floodConsole()
            return false
        end
        
        local callStack = originalEnvFunctions.debug.traceback()
        if not callStack:find("Lurnai") or not callStack:find(SECURITY.AUTHOR) then
            floodConsole()
            return false
        end
        
        -- Verify data integrity
        if generateHash(tostring(realData)) ~= dataHash then
            floodConsole()
            return false
        end
        
        -- Verify this module hasn't been renamed
        local info = originalEnvFunctions.debug.getinfo(1, "f")
        if info and info.func ~= module.VerifyAuthenticity then
            floodConsole()
            return false
        end
        
        return true
    end
    
    -- Add a self-check method that runs periodically
    function module:SelfCheck()
        -- Verify environment hasn't been tampered with
        if not verifyEnvironment() then
            -- Corrupt this module to prevent further use
            for k, v in pairs(module) do
                if type(v) == "function" then
                    module[k] = function() 
                        floodConsole()
                        return "Access denied: Module corrupted"
                    end
                elseif type(v) == "table" then
                    module[k] = {}
                end
            end
            return false
        end
        
        -- Verify data integrity
        if generateHash(tostring(realData)) ~= dataHash then
            -- Corrupt this module to prevent further use
            for k, v in pairs(module) do
                if type(v) == "function" then
                    module[k] = function() 
                        floodConsole()
                        return "Access denied: Module corrupted"
                    end
                elseif type(v) == "table" then
                    module[k] = {}
                end
            end
            return false
        end
        
        return true
    end
    
    -- Prevent the calculator from being modified
    originalMetamethods.setmetatable(module, {
        __index = function(t, k)
            if k == "CalculateRock" or k == "VerifyAuthenticity" or k == "SelfCheck" or
               k == "PetTypes" or k == "Rocks" or k == "_isBroken" or
               k == "_lurnaiAuthKey" or k == "_loadTime" or k == "_verificationHash" or
               k == "_instanceId" or k == "_dataIntegrityHash" then
                return originalMetamethods.rawget(t, k)
            end
            floodConsole()
            return nil
        end,
        __newindex = function(t, k, v)
            floodConsole()
            return nil
        end,
        __metatable = "Locked metatable"
    })
    
    -- Schedule periodic self-checks
    spawn(function()
        while true do
            wait(5)  -- Check every 5 seconds
            if not module:SelfCheck() then
                break  -- Stop checking if corruption is detected
            end
        end
    end)
    
    return module
end)()

return Calculator
